import os
import re
import logging
import random
import asyncio
import json
from datetime import datetime, timedelta
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.enums import ParseMode, MessageEntityType
from aiogram.exceptions import TelegramForbiddenError, TelegramBadRequest
from aiogram.fsm.storage.redis import RedisStorage
import redis.asyncio as redis

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
BOT_TOKEN = os.getenv("BOT_TOKEN")
REDIS_URL = os.getenv("REDIS_URL")

if not BOT_TOKEN:
    logger.error("‚ùå BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
    exit(1)

bot = Bot(token=BOT_TOKEN)

# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis
redis_client = None
storage = None

if REDIS_URL:
    try:
        redis_client = redis.from_url(REDIS_URL, decode_responses=True)
        storage = RedisStorage(redis=redis_client)
        logger.info("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ Redis")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Redis: {e}")
        redis_client = None
        storage = None
else:
    logger.warning("REDIS_URL –Ω–µ —É–∫–∞–∑–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è in-memory —Ö—Ä–∞–Ω–∏–ª–∏—â–µ.")

dp = Dispatcher(storage=storage)

# ========== –ü—É–Ω–∫—Ç 5: –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å—á–µ—Ç—á–∏–∫–∞ –æ—á–∏—Å—Ç–∫–∏ ==========
async def increment_cleanup_counter(chat_id: int) -> int:
    """–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—á–µ—Ç—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ"""
    if not redis_client:
        return 0
        
    key = f"chat:{chat_id}:counter"
    try:
        count = await redis_client.incr(key)
        if count >= 365:
            await redis_client.set(key, 0)
        return count
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å—á–µ—Ç—á–∏–∫–∞ –æ—á–∏—Å—Ç–∫–∏: {e}")
        return 0

# ========== –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ==========
def normalize_url(url: str) -> str:
    """–ü—Ä–∏–≤–æ–¥–∏–º URL –∫ –µ–¥–∏–Ω–æ–º—É –≤–∏–¥—É –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è"""
    url = url.split('?')[0].split('#')[0]
    if url.endswith('/'):
        url = url[:-1]
    return url.lower()

def extract_links(message: types.Message) -> list:
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Å—Å—ã–ª–∫–∏ –∏–∑ —Ç–µ–∫—Å—Ç–∞ –∏ –ø–æ–¥–ø–∏—Å–µ–π —Å —É—á—ë—Ç–æ–º Telegram entities"""
    urls = []
    text = message.text or message.caption or ""
    
    entities = message.entities or message.caption_entities or []
    for entity in entities:
        if entity.type == MessageEntityType.URL:
            url = text[entity.offset:entity.offset + entity.length]
            urls.append(url)
        elif entity.type == MessageEntityType.TEXT_LINK:
            urls.append(entity.url)
    
    if not urls:
        url_pattern = re.compile(
            r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+[/\w\.\-?=%&#@!$+]*'
        )
        urls = url_pattern.findall(text)
    
    normalized = []
    for url in urls:
        n_url = normalize_url(url)
        if n_url not in normalized:
            normalized.append(n_url)
    
    return normalized

async def save_link(chat_id: int, url: str, message_id: int):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å—Å—ã–ª–∫—É –≤ Redis"""
    if not redis_client:
        return
    
    # –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö
    link_data = {
        "message_id": message_id,
        "timestamp": datetime.now().isoformat()
    }
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Redis
    await redis_client.hset(
        f"chat:{chat_id}", 
        url, 
        json.dumps(link_data)
    )

async def get_link_data(chat_id: int, url: str) -> dict:
    """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ —Å—Å—ã–ª–∫–µ –∏–∑ Redis"""
    if not redis_client:
        return None
    
    data = await redis_client.hget(f"chat:{chat_id}", url)
    return json.loads(data) if data else None

async def cleanup_old_links(chat_id: int):
    """–£–¥–∞–ª—è–µ—Ç —Å—Ç–∞—Ä—ã–µ —Å—Å—ã–ª–∫–∏ (—Å—Ç–∞—Ä—à–µ 365 –¥–Ω–µ–π)"""
    if not redis_client:
        return
    
    all_links = await redis_client.hgetall(f"chat:{chat_id}")
    now = datetime.now()
    keys_to_delete = []
    
    for url, data_json in all_links.items():
        try:
            data = json.loads(data_json)
            timestamp = datetime.fromisoformat(data["timestamp"])
            
            if (now - timestamp) > timedelta(days=365):
                keys_to_delete.append(url)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Å—Å—ã–ª–∫–∏: {e}")
            continue
    
    # –£–¥–∞–ª—è–µ–º –≤—Å–µ —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ —Å—Å—ã–ª–∫–∏ –æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º
    if keys_to_delete:
        await redis_client.hdel(f"chat:{chat_id}", *keys_to_delete)
        logger.info(f"–£–¥–∞–ª–µ–Ω–æ {len(keys_to_delete)} —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö —Å—Å—ã–ª–æ–∫ –≤ —á–∞—Ç–µ {chat_id}")

async def delete_after_delay(message: types.Message, delay: int = 900):
    """–£–¥–∞–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —É–∫–∞–∑–∞–Ω–Ω—É—é –∑–∞–¥–µ—Ä–∂–∫—É (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)"""
    await asyncio.sleep(delay)
    try:
        await message.delete()
        logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ –±–æ—Ç–∞ {message.message_id} —É–¥–∞–ª–µ–Ω–æ –ø–æ—Å–ª–µ –∑–∞–¥–µ—Ä–∂–∫–∏")
    except (TelegramForbiddenError, TelegramBadRequest) as e:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –±–æ—Ç–∞: {e}")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –±–æ—Ç–∞: {e}")

# ========== –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π ==========
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    if message.chat.type == "private":
        await message.answer(
            "üõ°Ô∏è –Ø –±–æ—Ç-–∞–Ω—Ç–∏–¥—É–±–ª–∏–∫–∞—Ç–æ—Ä —Å—Å—ã–ª–æ–∫ —Å –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π –ø–∞–º—è—Ç—å—é!\n\n"
            "–î–æ–±–∞–≤—å –º–µ–Ω—è –≤ –≥—Ä—É–ø–ø—É –∫–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ —Å –ø—Ä–∞–≤–∞–º–∏:\n"
            "‚Ä¢ –£–¥–∞–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è\n"
            "‚Ä¢ –í–∏–¥–µ—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π\n\n"
            "–Ø –∑–∞–ø–æ–º–∏–Ω–∞—é –≤—Å–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ 365 –¥–Ω–µ–π, –¥–∞–∂–µ –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞!",
            parse_mode=ParseMode.HTML
        )

@dp.message(Command("status"))
async def cmd_status(message: types.Message):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ö—Ä–∞–Ω–∏–ª–∏—â–∞"""
    chat_id = message.chat.id
    if redis_client:
        link_count = await redis_client.hlen(f"chat:{chat_id}")
        await message.answer(
            f"üìä –°—Ç–∞—Ç—É—Å —Ö—Ä–∞–Ω–∏–ª–∏—â–∞:\n\n"
            f"‚Ä¢ –°—Å—ã–ª–æ–∫ –≤ –ø–∞–º—è—Ç–∏: <b>{link_count}</b>\n"
            f"‚Ä¢ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ Redis\n"
            f"‚Ä¢ –°—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è: 365 –¥–Ω–µ–π",
            parse_mode=ParseMode.HTML
        )
    else:
        await message.answer(
            "‚ÑπÔ∏è –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –≤ –ø–∞–º—è—Ç–∏. "
            "–î–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –ø–æ—Ç–µ—Ä—è–Ω—ã –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞.",
            parse_mode=ParseMode.HTML
        )

@dp.message(F.text | F.caption)
async def check_duplicate_links(message: types.Message):
    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ —Å–∞–º–æ–≥–æ –±–æ—Ç–∞
    if message.sender_chat or (message.from_user and message.from_user.id == (await bot.me()).id):
        return
    
    chat_id = message.chat.id
    links = extract_links(message)
    
    if not links:
        return
    
    # –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
    duplicate_found = False
    duplicate_url = None
    original_message_id = None
    
    for link in links:
        link_data = await get_link_data(chat_id, link)
        if link_data:
            duplicate_found = True
            duplicate_url = link
            original_message_id = link_data["message_id"]
            break
    
    # –®–∞–≥ 2: –ï—Å–ª–∏ –¥—É–±–ª–∏–∫–∞—Ç –Ω–∞–π–¥–µ–Ω - —É–¥–∞–ª—è–µ–º –∏ —É–≤–µ–¥–æ–º–ª—è–µ–º
    if duplicate_found:
        try:
            await message.delete()
        except TelegramForbiddenError:
            logger.error(f"–ù–µ—Ç –ø—Ä–∞–≤ –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ –≤ —á–∞—Ç–µ {chat_id}")
            await message.reply("‚ö†Ô∏è –£ –º–µ–Ω—è –Ω–µ—Ç –ø—Ä–∞–≤ —É–¥–∞–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
            return
        except TelegramBadRequest as e:
            logger.error(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: {e}")
            return
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        if str(chat_id).startswith("-100"):
            chat_part = str(chat_id)[4:]
        else:
            chat_part = chat_id
        
        response = (
            f"üëÆ‚ôÇÔ∏è <b>–û–±–Ω–∞—Ä—É–∂–µ–Ω –¥—É–±–ª–∏–∫–∞—Ç —Å—Å—ã–ª–∫–∏!</b>\n\n"
            f"–Ø –Ω–∞—à–µ–ª –∞–Ω–∞–ª–æ–≥–∏—á–Ω—É—é —Å—Å—ã–ª–∫—É –≤ –∏—Å—Ç–æ—Ä–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π:\n"
            f"<code>{duplicate_url}</code>\n\n"
            f"<a href='https://t.me/c/{chat_part}/{original_message_id}'>‚Üí –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—É</a>"
        )
        
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –¥—É–±–ª–∏–∫–∞—Ç–µ
            warning_msg = await bot.send_message(
                chat_id=chat_id,
                text=response,
                parse_mode=ParseMode.HTML,
                disable_web_page_preview=True
            )
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç (900 —Å–µ–∫—É–Ω–¥)
            asyncio.create_task(delete_after_delay(warning_msg))
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è: {e}")
        
        return
    
    # –®–∞–≥ 3: –ï—Å–ª–∏ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ –Ω–µ—Ç - —Å–æ—Ö—Ä–∞–Ω—è–µ–º –í–°–ï —Å—Å—ã–ª–∫–∏ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
    for link in links:
        await save_link(chat_id, link, message.message_id)
    
    logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {len(links)} —Å—Å—ã–ª–æ–∫ –≤ —á–∞—Ç–µ {chat_id}")

    # –®–∞–≥ 4: –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö —Å—Å—ã–ª–æ–∫ (1 —Ä–∞–∑ –Ω–∞ 365 —Å–æ–æ–±—â–µ–Ω–∏–π)
    # === –ü—É–Ω–∫—Ç 5: –ò—Å–ø–æ–ª—å–∑—É–µ–º Redis-—Å—á–µ—Ç—á–∏–∫ –≤–º–µ—Å—Ç–æ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π ===
    current_count = await increment_cleanup_counter(chat_id)
    if current_count >= 365:
        await cleanup_old_links(chat_id)
        logger.info(f"–ó–∞–ø—É—â–µ–Ω–∞ –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö —Å—Å—ã–ª–æ–∫ –≤ —á–∞—Ç–µ {chat_id}")

# ========== –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ ==========
async def main():
    logger.info("Starting bot...")
    await bot.delete_webhook(drop_pending_updates=True)  # –í–∞–∂–Ω–æ –¥–ª—è –ø–æ–ª–ª–∏–Ω–≥–∞ –Ω–∞ Render
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())