import os
import re
import logging
import random
from datetime import datetime, timedelta
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.enums import ParseMode, MessageEntityType
from aiogram.exceptions import TelegramForbiddenError, TelegramBadRequest
import asyncio
import redis.asyncio as redis
import json

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
BOT_TOKEN = os.getenv("BOT_TOKEN")
REDIS_URL = os.getenv("REDIS_URL")

if not BOT_TOKEN:
    logger.error("‚ùå BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
    exit(1)

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis
redis_client = None
if REDIS_URL:
    try:
        redis_client = redis.from_url(REDIS_URL, decode_responses=True)
        logger.info("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ Redis")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Redis: {e}")
        redis_client = None
else:
    logger.warning("REDIS_URL –Ω–µ —É–∫–∞–∑–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è in-memory —Ö—Ä–∞–Ω–∏–ª–∏—â–µ.")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Å—á–µ—Ç—á–∏–∫ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –æ—á–∏—Å—Ç–∫–∏
cleanup_counter = 0

def normalize_url(url: str) -> str:
    """–ü—Ä–∏–≤–æ–¥–∏–º URL –∫ –µ–¥–∏–Ω–æ–º—É –≤–∏–¥—É –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è"""
    url = url.split('?')[0].split('#')[0]
    if url.endswith('/'):
        url = url[:-1]
    return url.lower()

def extract_links(message: types.Message) -> list:
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Å—Å—ã–ª–∫–∏ –∏–∑ —Ç–µ–∫—Å—Ç–∞ –∏ –ø–æ–¥–ø–∏—Å–µ–π —Å —É—á—ë—Ç–æ–º Telegram entities"""
    urls = []
    text = message.text or message.caption or ""
    
    entities = message.entities or message.caption_entities or []
    for entity in entities:
        if entity.type == MessageEntityType.URL:
            url = text[entity.offset:entity.offset + entity.length]
            urls.append(url)
        elif entity.type == MessageEntityType.TEXT_LINK:
            urls.append(entity.url)
    
    if not urls:
        url_pattern = re.compile(
            r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+[/\w\.\-?=%&#@!$+]*'
        )
        urls = url_pattern.findall(text)
    
    normalized = []
    for url in urls:
        n_url = normalize_url(url)
        if n_url not in normalized:
            normalized.append(n_url)
    
    return normalized

async def save_link(chat_id: int, url: str, message_id: int):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å—Å—ã–ª–∫—É –≤ Redis"""
    if not redis_client:
        return
    
    # –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö
    link_data = {
        "message_id": message_id,
        "timestamp": datetime.now().isoformat()
    }
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Redis
    await redis_client.hset(
        f"chat:{chat_id}", 
        url, 
        json.dumps(link_data)
    )

async def get_link_data(chat_id: int, url: str) -> dict:
    """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ —Å—Å—ã–ª–∫–µ –∏–∑ Redis"""
    if not redis_client:
        return None
    
    data = await redis_client.hget(f"chat:{chat_id}", url)
    return json.loads(data) if data else None

async def cleanup_old_links(chat_id: int):
    """–£–¥–∞–ª—è–µ—Ç —Å—Ç–∞—Ä—ã–µ —Å—Å—ã–ª–∫–∏ (—Å—Ç–∞—Ä—à–µ 365 –¥–Ω–µ–π)"""
    if not redis_client:
        return
    
    all_links = await redis_client.hgetall(f"chat:{chat_id}")
    now = datetime.now()
    keys_to_delete = []
    
    for url, data_json in all_links.items():
        try:
            data = json.loads(data_json)
            timestamp = datetime.fromisoformat(data["timestamp"])
            
            if (now - timestamp) > timedelta(days=365):
                keys_to_delete.append(url)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Å—Å—ã–ª–∫–∏: {e}")
            continue
    
    # –£–¥–∞–ª—è–µ–º –≤—Å–µ —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ —Å—Å—ã–ª–∫–∏ –æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º
    if keys_to_delete:
        await redis_client.hdel(f"chat:{chat_id}", *keys_to_delete)
        logger.info(f"–£–¥–∞–ª–µ–Ω–æ {len(keys_to_delete)} —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö —Å—Å—ã–ª–æ–∫ –≤ —á–∞—Ç–µ {chat_id}")

async def delete_after_delay(message: types.Message, delay: int = 900):
    """–£–¥–∞–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —É–∫–∞–∑–∞–Ω–Ω—É—é –∑–∞–¥–µ—Ä–∂–∫—É (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)"""
    await asyncio.sleep(delay)
    try:
        await message.delete()
        logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ –±–æ—Ç–∞ {message.message_id} —É–¥–∞–ª–µ–Ω–æ –ø–æ—Å–ª–µ –∑–∞–¥–µ—Ä–∂–∫–∏")
    except (TelegramForbiddenError, TelegramBadRequest) as e:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –±–æ—Ç–∞: {e}")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –±–æ—Ç–∞: {e}")

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    if message.chat.type == "private":
        await message.answer(
            "üõ°Ô∏è –Ø –±–æ—Ç-–∞–Ω—Ç–∏–¥—É–±–ª–∏–∫–∞—Ç–æ—Ä —Å—Å—ã–ª–æ–∫ —Å –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π –ø–∞–º—è—Ç—å—é!\n\n"
            "–î–æ–±–∞–≤—å –º–µ–Ω—è –≤ –≥—Ä—É–ø–ø—É –∫–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ —Å –ø—Ä–∞–≤–∞–º–∏:\n"
            "‚Ä¢ –£–¥–∞–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è\n"
            "‚Ä¢ –í–∏–¥–µ—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π\n\n"
            "–Ø –∑–∞–ø–æ–º–∏–Ω–∞—é –≤—Å–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ 365 –¥–Ω–µ–π, –¥–∞–∂–µ –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞!",
            parse_mode=ParseMode.HTML
        )

@dp.message(Command("status"))
async def cmd_status(message: types.Message):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ö—Ä–∞–Ω–∏–ª–∏—â–∞"""
    chat_id = message.chat.id
    if redis_client:
        link_count = await redis_client.hlen(f"chat:{chat_id}")
        await message.answer(
            f"üìä –°—Ç–∞—Ç—É—Å —Ö—Ä–∞–Ω–∏–ª–∏—â–∞:\n\n"
            f"‚Ä¢ –°—Å—ã–ª–æ–∫ –≤ –ø–∞–º—è—Ç–∏: <b>{link_count}</b>\n"
            f"‚Ä¢ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ Redis\n"
            f"‚Ä¢ –°—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è: 365 –¥–Ω–µ–π",
            parse_mode=ParseMode.HTML
        )
    else:
        await message.answer(
            "‚ÑπÔ∏è –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –≤ –ø–∞–º—è—Ç–∏. "
            "–î–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –ø–æ—Ç–µ—Ä—è–Ω—ã –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞.",
            parse_mode=ParseMode.HTML
        )

@dp.message()
async def check_duplicate_links(message: types.Message):
    global cleanup_counter
    
    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ —Å–∞–º–æ–≥–æ –±–æ—Ç–∞
    if message.sender_chat or (message.from_user and message.from_user.id == (await bot.me()).id):
        return
    
    chat_id = message.chat.id
    links = extract_links(message)
    
    if not links:
        return
    
    # –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
    duplicate_found = False
    duplicate_url = None
    original_message_id = None
    
    for link in links:
        link_data = await get_link_data(chat_id, link)
        if link_data:
            duplicate_found = True
            duplicate_url = link
            original_message_id = link_data["message_id"]
            break
    
    # –®–∞–≥ 2: –ï—Å–ª–∏ –¥—É–±–ª–∏–∫–∞—Ç –Ω–∞–π–¥–µ–Ω - —É–¥–∞–ª—è–µ–º –∏ —É–≤–µ–¥–æ–º–ª—è–µ–º
    if duplicate_found:
        try:
            await message.delete()
        except TelegramForbiddenError:
            logger.error(f"–ù–µ—Ç –ø—Ä–∞–≤ –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ –≤ —á–∞—Ç–µ {chat_id}")
            await message.reply("‚ö†Ô∏è –£ –º–µ–Ω—è –Ω–µ—Ç –ø—Ä–∞–≤ —É–¥–∞–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
            return
        except TelegramBadRequest as e:
            logger.error(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: {e}")
            return
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        if str(chat_id).startswith("-100"):
            chat_part = str(chat_id)[4:]
        else:
            chat_part = chat_id
        
        response = (
            f"üëÆ‚ôÇÔ∏è <b>–û–±–Ω–∞—Ä—É–∂–µ–Ω –¥—É–±–ª–∏–∫–∞—Ç —Å—Å—ã–ª–∫–∏!</b>\n\n"
            f"–Ø –Ω–∞—à–µ–ª –∞–Ω–∞–ª–æ–≥–∏—á–Ω—É—é —Å—Å—ã–ª–∫—É –≤ –∏—Å—Ç–æ—Ä–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π:\n"
            f"<code>{duplicate_url}</code>\n\n"
            f"<a href='https://t.me/c/{chat_part}/{original_message_id}'>‚Üí –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—É</a>"
        )
        
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –¥—É–±–ª–∏–∫–∞—Ç–µ
            warning_msg = await bot.send_message(
                chat_id=chat_id,
                text=response,
                parse_mode=ParseMode.HTML,
                disable_web_page_preview=True
            )
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç (900 —Å–µ–∫—É–Ω–¥)
            asyncio.create_task(delete_after_delay(warning_msg))
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è: {e}")
        
        return
    
    # –®–∞–≥ 3: –ï—Å–ª–∏ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ –Ω–µ—Ç - —Å–æ—Ö—Ä–∞–Ω—è–µ–º –í–°–ï —Å—Å—ã–ª–∫–∏ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
    for link in links:
        await save_link(chat_id, link, message.message_id)
    
    logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {len(links)} —Å—Å—ã–ª–æ–∫ –≤ —á–∞—Ç–µ {chat_id}")

    # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö —Å—Å—ã–ª–æ–∫ (1 —Ä–∞–∑ –Ω–∞ 365 —Å–æ–æ–±—â–µ–Ω–∏–π)
    cleanup_counter += 1
    if cleanup_counter >= 365:
        asyncio.create_task(cleanup_old_links(chat_id))
        cleanup_counter = 0
        logger.info(f"–ó–∞–ø—É—â–µ–Ω–∞ –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö —Å—Å—ã–ª–æ–∫ –≤ —á–∞—Ç–µ {chat_id}")

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
async def main():
    logger.info("Starting bot...")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())